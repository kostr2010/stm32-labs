## Лабораторная 3 "Энкодер"

В данной работе будет рассмотрена базовая работа с энкодером, а также рассмотрены возможные варианты ее реализации.
Навыки работы с энкодром могут пригодиться при реализации финального проекта, т.к. по своей сути, энкодер функционально идентичен колесику мыши, т.е. способен измерять направление и скорость своего вращения

### Работа таймера в режиме энкодера

У некоторых таймеров имеется возможность работать с энкодером. Для этого есть специальный режим таймера **encoder mode**.
Сигнал принимается с двух каналов `CH1` и `CH2` сразу, и в зависимости от вращения счётчик таймера уменьшается или увеличивается.
Чтобы понять как это работает, взгляните в **табличку из reference manual**. Сейчас интерес представляет **последняя строчка**.

<p align="center">
  <img width="700" src="https://github.com/Levitsky-Ilya/stm32f0_ARM/blob/master/docs/images/table.jpg" alt="table.jpg"/>

</p>

Таймер считает вверх или вниз во-первых в зависимости от фронта или спада каналов (которые `TI1` и `TI2`), а во-вторых от прошлого состояния каналов. График зависимости сигналов на входе и счётчика от времени поясняет логику таблицы.

<p align="center">
  <img width="700" src="https://github.com/Levitsky-Ilya/stm32f0_ARM/blob/master/docs/images/graph.jpg" alt="graph.jpg"/>

</p>

Из таблицы видно, что можно заставить таймер реагировать не только на фронты обоих каналов, но и фронты лишь одного канала. Например, cчётчик будет изменяться только после перепада на `TI1`. Такой режим может быть нужен, когда один из каналов часто останавливается в промежуточном положении и возникает jitter. Или можно выставить ненулевое значение предделителя тактирующей частоты. При любом из подходов борьбы с таким дребезгом таймер будет отсчитывать меньше за один оборот энкодера.

### Hастройка энкодера в коде

Рассмотрим функцию SetEncoder в ./lib/device-drivers/encoder.h.

Не считая установки источника тактирования как для пинов, так и для таймера, работа с таймером начинается с настройки его каналов; их необходимо два: `CH1` и `CH2`. Им соответствуют пины `pin_l` и `pin_r`. Для обоих пинов включён альтернативный режим, функция `LL_GPIO_AF_2`, подтяжка вверх.

Настройки энкодера

```C
  // Настройка пинов pin_r и pin_l в качестве каналов CH1 и CH2 таймера timer
  // Выставляем подтяжку вверх, т.к. средняя ножка энкодера должна быть заземлена
  LL_GPIO_SetPinMode(port, pin_r, LL_GPIO_MODE_ALTERNATE);
  LL_GPIO_SetPinMode(port, pin_l, LL_GPIO_MODE_ALTERNATE);
  LL_GPIO_SetAFPin_0_7(port, pin_r, LL_GPIO_AF_2);
  LL_GPIO_SetAFPin_0_7(port, pin_l, LL_GPIO_AF_2);
  LL_GPIO_SetPinPull(port, pin_r, LL_GPIO_PULL_UP);
  LL_GPIO_SetPinPull(port, pin_l, LL_GPIO_PULL_UP);
```

Настройки таймера

```C
  // Включаем режим энкодера. Так как хотелось бы реагировать на каждый фронт обоих
  // каналов, как описано на третьей строчке таблицы, то это указывается аргументом:
  LL_TIM_SetEncoderMode(timer, LL_TIM_ENCODERMODE_X4_TI12);

  // Данный микроконтроллер поддерживает только детектирование одного фронта (falling or rising)
  // поэтому выбираем один из них и прописываем его для обоих каналов
  LL_TIM_IC_SetPolarity(timer, LL_TIM_CHANNEL_CH1, LL_TIM_IC_POLARITY_FALLING);
  LL_TIM_IC_SetPolarity(timer, LL_TIM_CHANNEL_CH2, LL_TIM_IC_POLARITY_FALLING);

  // Выставляем время перезарядки таймера, включаем его
  LL_TIM_SetAutoReload(timer, 0xFFFF);
  LL_TIM_EnableCounter(timer);
```

### main

В функции main представлено несколько способов детектирования направления врщения энкодера (каждый раз визуализируются через подключенные диоды, могут быть как внешние, так и встроенные PIN_8 и PIN_9 порта GPIOB). Непосредственный интерес в рамках этой лабораторной представляет только option 1, но остальные подходы тоже полезно изучить в целях ознакомления с возможностями нашего микроконтроллера. Подробное описание каждого из алгоритмов приведено непосредственно перед участком кода в main.c

## Самостоятельные задания

Подключите энкодер и пронаблюдйте, как светодиоды реагируют на вращение энкодера.

Стандартное задание - вывести значение таймера на индикатор. Оцените, насколько быстро растёт счётчик при одном повороте.
